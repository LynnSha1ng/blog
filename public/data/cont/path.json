{
  "name": "path",
  "cont": "```js\r\nimport path from 'node:path';\r\n\r\n// 注：当前工作目录为 'C:\\Users\\a\\Desktop\\NodeStudy'\r\n\r\n// path.sep返回当前系统的路径分隔符，POSIX为'/'，Win为'\\'\r\n\r\n'path\\\\to\\\\file.txt'.split(path.sep); // [ 'path', 'to', 'file.txt' ]\r\n\r\n// path.delimiter返回当前系统的路径定界符，POSIX为':'，Win为';'\r\n\r\nprocess.env.PATH.split(path.delimiter);\r\n\r\n// ['C:\\\\Windows\\\\system32', 'C:\\\\Windows', ... ]\r\n\r\n// 返回路径的最后一部分，并删除 `suffix` 后缀名（区分大小写）\r\n\r\npath.basename('path/to/file.txt', '.TXT'); // 'file.txt'\r\n\r\n// 返回目录名，忽略尾部分隔符\r\n\r\npath.dirname('path/to/file.txt'); // 'path/to'\r\n\r\n// 返回后缀名\r\n\r\npath.extname('path/to/file.txt'); // '.txt'\r\n\r\npath.extname('.minecraft'); // ''\r\n\r\npath.extname('file.'); // '.'\r\n\r\n// 连接并规范path，忽略零长度的 path 片段。\r\n\r\npath.join('/foo', './bar', 'baz\\\\asdf', 'quux', '..'); // '\\foo\\bar\\baz\\asdf'\r\n\r\n// 如果连接的路径字符串最后是零长度字符串，则将返回当前工作目录\r\n\r\npath.join('foo/bar', '../../'); // '.\\'\r\n\r\n// 将path解析为绝对路径并规范。从右到左处理，直到解析到绝对路径为止。注意盘符不会被忽略\r\n\r\npath.resolve('D:/test', '\\\\foo', 'bar', 'file'); // 'D:\\foo\\bar\\file'\r\n\r\n// 如果最终还没有生成绝对路径，则使用当前工作目录的绝对路径。\r\n\r\npath.resolve('test', 'static\\\\png\\\\', './../gif/image.gif');\r\n\r\n// 'C:\\Users\\a\\Desktop\\NodeStudy\\test\\static\\gif\\image.gif'\r\n\r\n// 返回一个含有path重要元素的对象，与path.format为互逆操作，注意该方法不会规范化\r\n\r\nconst pathObj = path.parse(path.normalize('/home/user/dir/file.txt'));\r\n\r\n// { root: '\\\\',\r\n\r\n//   dir: '\\\\home\\\\user\\\\dir',\r\n\r\n//   base: 'file.txt',\r\n\r\n//   ext: '.txt',\r\n\r\n//   name: 'file' }\r\n\r\npath.format(pathObj); // \\home\\user\\dir\\file.txt\r\n\r\n// 返回从from到to的相对路径，若from和to相同则返回空字符串\r\n\r\npath.relative('C:/test1/aaa', 'C:\\\\test2\\\\bbb'); // '..\\..\\test2\\bbb'\r\n\r\n// 若存在相对路径或空字符串，则以当前工作目录为基准。\r\n\r\npath.relative('', 'C:/test1/aaa'); // '..\\..\\..\\..\\test1\\aaa'\r\n\r\n// 返回是否为绝对路径\r\n\r\npath.isAbsolute('/foo/bar/'); // true\r\n```\r\n"
}