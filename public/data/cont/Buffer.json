{
  "name": "Buffer",
  "cont": "## 1. 概念\r\n\r\n`Buffer`对象用于表示固定长度的字节序列。许多 Node.js API 都支持 `Buffer` 。它是 `Uint8Array` 类的子类，Node.js API 在支持 `Buffer` 的地方也接受纯 `Uint8Array` 。它在全局作用域内可用，但仍然建议显式引用它。\r\n\r\n## 2. 特点\r\n\r\n- 大小固定\r\n- 性能好，直接操作内存\r\n- 每个元素大小为1字节\r\n\r\n## 3. 使用\r\n\r\n### 3.1 创建\r\n\r\n- `Buffer.alloc(size: number, fill?: string | Uint8Array | number, encoding?: BufferEncoding): Buffer`\r\n      创建一个长度为 size 的 Buffer，以 fill 填充，以 encoding 编码。 fill 默认为0。\r\n- `Buffer.allocUnsafe(size: number): Buffer`\r\n      以这种方式创建的 Buffer 实例的底层内存没有被初始化。新创建的 Buffer 的内容未知，可能包含敏感数据。\r\n- `Buffer.from`\r\n\r\n```js\r\nimport { Buffer } from 'node:buffer';\r\n\r\n/**\r\n\r\n * integer[]\r\n\r\n * 元素值为 0 - 255，超过则截断\r\n\r\n */\r\n\r\nconst buf1 = Buffer.from([0x68, 0x65, 0x6c, 0x6c, 0x6f]);\r\n\r\n/**\r\n\r\n * arrayBuffer, byteOffset?, length?\r\n\r\n * arrayBuffer 为 <ArrayBuffer>、<SharedArrayBuffer>，例如 TypedArray 的 buffer 属性。\r\n\r\n * byteOffset 和 length 参数指定了 arrayBuffer 中与 Buffer 共享的内存范围。\r\n\r\n */\r\n\r\nconst arr = new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f]);\r\n\r\nconst buf2 = Buffer.from(arr.buffer, 2, 3); // 取后三个字符\r\n\r\nfor (let i = 0; i < arr.length; i++) arr[i] += 1;\r\n\r\nconsole.log(buf2.toString()); // 输出 mmp\r\n\r\n/**\r\n\r\n * Buffer | Unit8Array\r\n\r\n * 相当于复制 Buffer，不共享内存\r\n\r\n */\r\n\r\nconst _buf3 = Buffer.alloc(5, 'hello');\r\n\r\nconst buf3 = Buffer.from(_buf3);\r\n\r\n/**\r\n\r\n * object, offsetOrEncoding?, length?\r\n\r\n * object 必须支持 valueOf() 或 Symbol.toPrimitive\r\n\r\n */\r\n\r\n//支持 valueOf()\r\n\r\nconst buf4a = Buffer.from(new String('hello'));\r\n\r\n//支持 Symbol.toPrimitive，hint 传参'string'\r\n\r\nconst buf4b = Buffer.from(\r\n  new (class {\r\n    [Symbol.toPrimitive](hint) {\r\n      if (hint === 'number') return 10;\r\n\r\n      if (hint === 'string') return 'hello';\r\n\r\n      return true;\r\n    }\r\n  })(),\r\n\r\n  'utf8',\r\n);\r\n\r\n/**\r\n\r\n * string, encoding?\r\n\r\n */\r\n\r\nconst buf5 = Buffer.from('hello', 'ascii');\r\n```\r\n"
}